# 模板元编程

### 模板函数

* 使用template\<class T>
* 其中T可以是任意类型

```cpp
template <class T>
T twice(T t){
    return t*2;
}
int main(){
    std::cout<<twice<int>(21)<<std::endl;
    std::cout<<twice<float>(2.11f)<<std::endl;
    std::cout<<twice<double>(2.22)<<std::endl;
}
```

**注意：**有些人写作

```cpp
template<typename T>
```

这两个是完全等价的，都可以用。

**自动类型推断**

在上面哪个例子中，main函数这样写也是成立的。

```cpp
int main(){
    std::cout<<twice(21)<<std::endl;
    std::cout<<twice(2.11f)<<std::endl;
    std::cout<<twice(2.22)<<std::endl;
}
```

**特殊重载**

有时候，一个统一的实现满足不了特殊情况，这个时候根据特殊情况写一个特例重载就行。

如若是string类型，没有t*2的操作，于是我们可以写个重载为t+t；

```cpp
template <class T>
T twice(T t){
    return t*2;
}
std::string twice(std::string t){	//他会和已有的模板twice(T t)重载。
    return t+t;
}
```



**模板参数**

除了class为模板参数以外，int和枚举类型也作为模板参数

```cpp
template <int N>
void show_times(std::string msg){
    for(int i=0;i<N;i++){
        std::cout<<msg<<Std::endl;
    }
}
```

**多个模板参数**

* int N 和chass T 可以一起使用。
* 你只需要指定一部分参数，编译器会根据参数类型，默认值，推断尖括号内没有指定的那些参数。

```cpp
template <int N=1, class T>
void show_times(T msg){
    for(int i=0;i<N;i++){
        std::cout<<msg<<Std::endl;
    }
}
int main(){
    show_times("one");
    show_times<3>(42);
    show_times<4>('%');
}
```

**参数的部分特化**

```cpp
template <class T>
T sum(std::Vector<T> const &arr){
	T res=0;
    for(int i=0;i<arr.size();i++){
		res+=arr[i];
    }
    return res;
}

int main(){
    std::vector<int> a={4,3,2,1};
    std::cout<<sum(a)<<std::endl;
    std::vector<float> b={3.14f,2,33f};
    std::cout<<sum(b)<<std::endl;
}
```

* func(T t)完全让调用者决定参数类型。
* func(vector\<T> t)可以限定仅仅为vector类型的参数。
* 这种部分特化不支持隐式转换。

**模板参数和普通的函数参数有什么区别？**

* template \<int N> 传入的是编译器常量，每个不同的N，编译器都会单独生成一份代码，从而可以做单独优化。
* func(int N)，则会变成运行期常量，编译器无法自动优化。

比如show_times<0>()，编译器会自动优化为空函数，因此，模板元编程对高性能编程很重要。

通常来说，模板的内部实现需要被暴露出来，所以，定义和实现都必须放在头文件中。

应用：

```cpp
int sumto(int n,bool debug){
	int res=0;
    for(int i=1;i<=n;i++){
        res+=i;
        if(debug)//即使debug为false,此处还是会损失cpu时间。
            std::cout<<i<<"-th:"<<res<<std::endl;
    }
}
//利用模板参数来优化
template<bool debug>
int sumto(int n){
    int res=0;
    for(int i=1;i<=n;i++){
		res+=i;
        if(debug)//此处判断会在编译时执行，若为false则直接清除这两行。
    		std::cout<<i<<"-th:"<<res<<std::endl;   
        //有些编译器不那么智能，没法识别出debug为编译期常量怎么办
        //我们可以添加 constexpr关键字确保它在编译期生效
        if constexpr (debug)
            std::cout<<i<<"-th:"<<res<<std::endl;
    }
}

```



**constexpr 编译期常量的限制**

* 编译期常量的限制在于不能通过**运行时变量**组成的表达式来指定，如：

```cpp
int i=3;
if constexpr (i%2)
    ...
```

这里i为运行时变量，无法作为编译器分支的条件。

* 除了if constexpr 的表达式不能用运行时常量，模板内尖括号内的参数也不行。

```cpp
int main(){
    bool debug =true;
    std::cout<<sumto<debug>(4)<<std::endl;//debug为运行时变量，不行
    return 0;
}
```

* 解决方案：为debug添加constexpr关键字，即：

```cpp
int main(){
    constexpr bool debug =true;
    std::cout<<sumto<debug>(4)<<std::endl;//debug为运行时变量，不行
    return 0;
}
```

* 由constexpr修饰的函数，也是可以在编译期执行，求值的。

 ```cpp
 constexpr bool isnagative(int n){
     return n<0;
 }
 ```

注意，constexpr函数不能调用non-constexpr函数。而且constexpr函数必须是内联的，不能分离声明和实现在另外一个文件里，标准库中很多函数如std::min也是constexpr函数，可以放心在模板尖括号内使用。

**惰性**

编译器对模板的编译是惰性的，即，只有当前.cpp文件用到这个模板，该模板的函数才会被定义。

要证明模板的惰性，只需看这个例子：

```cpp
template <class T=void>
void func_never_pass_compile(){
    "string"="1234";//明显这是一条错误的语句，通常是不能通过编译的,但是因为这个模板函数从来没有被调用过，不会实际被编译，因此可以通过编译。
}
int main()
{
    return 0;
}
```

* 一般用一个假的模板实现延迟编译的技术，可以加快编译速度，用于代理模式等。

**想要看编译出的重载模板函数怎么办**

字段**\__PRETTY_FUNCTION__**表示当前重载函数的名称，可以通过std::cout打印出来。

### 自动类型推导

C++11引入auto，以实现自动类型推导。

**auto用来定义变量**

使用auto定义的变量，其类型会自动根据等号右边的值来确定，这样可以避免特别长的变量定义。

```cpp
struct MyClassWithVeryLongName{
    
};
int main(){
    auto p=std::make_shared<MyClassWithVeryLongName>();
}
```

**auto作为返回值**

使用auto定义返回值，其类型可以由return类型推导出来。

```cpp
auto func(){
    return std::make_shared<C>();
}
```

**注意：**

* 当函数有多条返回值语句，需保证所有返回类型一致，否则auto将报错。
*  当函数没有return语句，auto将被推导为void。
* 若声明与实现分离，则不能声明为auto，如：

```cpp
auto func();//错误
```

**限制**

不能单独声明auto变量。

```cpp
auto p;//不合法
```

类成员不可以定义为auto:

```cpp
struct C{
    auto x=std::make_shared<int>();//不合法
}
```

**获取类型**

```cpp
struct A;
int main()
{
	A a;
	cout<<typeid(a);//获取a的类型。
}
```

